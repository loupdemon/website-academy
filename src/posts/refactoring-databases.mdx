---
title: "Refactoring databases"
date: 2020-06-07
author: arthur
tags: [base de datos, agil, dise침o]
description: Refactorizar bases de datos o como evolucionar bases de datos, en vez de dise침ar bases de datos al inicio de un proyecto
image: https://pbs.twimg.com/media/EVXp9H8X0AAd50J?format=jpg&name=large
---

Es muy pero muy com칰n escuchar en los desarrolladores (o capacitadores, profesores...) que una de las cosas b치sicas que un proyecto debe tener al inicio es una base de datos definida. Sin embargo esto no tiene que ser as칤, de hecho rompe lo que es el enfoque agil, aqu칤 es donde refactorizar bases de datos (database refactoring) ayuda y mucho.

Si bien, refactoring es una t칠cnica muy conocida en el desarrollo de software, una t칠cnica disciplinada para reestructurar c칩digo con el fin de hacer m치s mantenible el software [1], permite el dise침o de software evolutivo ([evolutionary design](https://martinfowler.com/tags/evolutionary%20design.html)),que en el fondo ayuda a lograr la agilidad. El t칠rmino refactoring es usualmente es solo referido al c칩digo fuente de la aplicaci칩n (el c칩digo escrito en lenguajes como java, python, javascript, php...), cuando puede aplicarse a bases de datos.

Al igual que en el refactoring tradicional, database refactoring ayuda al dise침o evolutivo, m치s especifico al dise침o evolutivo de bases de datos, claro que para ello distintas t칠cnicas son necesarias, como el [modelado de datos agil](http://www.agiledata.org/essays/bestPractices.html). De nuevo, esto habilita la agilidad, recuerda sin pr치cticas t칠cnicas cosas como [scrum fl치cido pueden suceder](https://martinfowler.com/bliki/FlaccidScrum.html).

Pero a primera vista pensaras que database refactoring debe ser lo mismo que hacer un refactoring tradicional, y la verdad es que es mucho m치s dificil, debido a el riesgo de borrar informaci칩n, peor a칰n este riesgo incrementa cuando una base de datos es usada por muchas aplicaciones (lo cual es usual), a lo que llamamos el patr칩n (o antipatron) [integration database](https://martinfowler.com/bliki/IntegrationDatabase.html).

Imaginate cambiar el nombre de un campo de la tabla `customer` de `f_name` a `first_name`, uno podr칤a ejecutar un simple `UPDATE` pero las cosas no son tan faciles, ser치 necesario actualizar toda referencia a ella en tus aplicaciones, si usas un ORM, cambiar su mapeo, de:

```java
class Person {
    @Column("f_name")
    String fistName;
}
```

```java
class Person {
    @Column("first_name")
    String fistName;
}
```

Adem치s toda query que usen las aplicaciones, sean estas planas o usando algun query del ORM, por ejemplo de `SELECT f_name, last_name, ... FROM customer` a `SELECT first_name, last_name, ... FROM customer`.

M치s a칰n cuando se tiene 2 o m치s aplicaciones que acceden, se deberan cambiar ambas, sin embargo esto no siempre es posible! Si, muchas veces otras aplicaciones son desarrolladas o mantenidas por otros equipos (que pueden estar incluso fuera de tu organizaci칩n), no todos podran realizar el cambio de manera inmediata. Incluso, la base de datos puede estar siendo usada por otras bases de datos, datawarehouses (o datamarts), ... (de vez en cuando te topas con esas mounstrosidades 游뗽)

As칤 que cuando tengas integration databases, las cosas se complican y mucho...un simple `UPDATE` no es la soluci칩n, ser치 necesario crear un mecanismo que permita que las aplicaciones se adapten a los nuevos bases de datos, sin afectar a las otras aplicaciones, darles un **periodo de transicion**, hasta que estas actualicen al nuevo esquema (que usen `first_name` en vez de `f_name`)

Y como es usual, **refactoring necesita de testing**, igual sucede en refactoring databases, uno no simplemente ejecuta un `UPDATE` y espera que todo este bien.

El libro de Scott Ambler y Pramod Sadalage es un libro fascinante, que estaba muy adelantado a su 칠poca, da unas pr치cticas pilares para el dise침o evolutivo de bases de datos, como developer sandboxes, donde cada desarrollador tiene su propia BD donde pueda testear los cambios (los refactorings) y que este debe ser facilmente levantado con un comando (notas algo de relacion con docker? 游뱂) o [sobre versionar todo en una base de datos, sus tablas, stored procedures, test data](/posts/versionamiento-de-base-de-datos.mdx), da esa discusi칩n en detalle sobre IntegrationDatabases y bases de datos aisladas, y da en s칤 el catalogo de refactorings aplicado a ambos tipos de bases de datos, adem치s de discusi칩n de como desarrollar y desplegar esos refactorings.

<Tweet tweetLink="artmadeit/status/1249161759266672641/photo/1" />

Mi libro refactoring databases, tuve 2 likes de los propios autores 游밿

El libro es excelente, hay algunos refactorings b치sicos, que siento que a un estudiante le ayudar칤a un monton (aunque a un experto puede cansarlo un poco), sin embargo el libro es un poco antiguo, est치 enfocado a bases de datos relacionales (en esa 칠poca pr치cticamente eran los unicos), por lo que seria interesante ver otros libros aplicados a bases de datos NoSQL, adem치s en esa 칠poca habia muy pocas herramientas para ayudar a refactorizar (aunque siento que como se las imagino en el libro, es algo que a칰n las herramientas actuales deben seguir), hoy en d칤a pr치cticamente para cada lenguaje y sus frameworks existen distintas [Flyway](https://flywaydb.org/), [laravel migrations](https://laravel.com/docs/7.x/migrations), [django migrations](https://docs.djangoproject.com/en/3.0/topics/migrations/), [typeorm](https://typeorm.io/#/migrations)...sin embargo, existe un post muy pero muy bueno donde ver como cambio el libro luego de [m치s de 5 a침os y que toca el tema en si de evolutionary databases](https://martinfowler.com/articles/evodb.html)

## Referencias

1. Fowler, M. (2018). Refactoring: improving the design of existing code. Addison-Wesley Professional.
